<<Sort an array of 0's, 1's and 2's>>
TC: O(N) | SC: O(1)

Divide the array into three parts such that after traversal, 
all integers left of 'low' are equal to 0, 
all integers right of 'high' are equal to 2
and all integers between the two are equal to 1.

<<Kadane's Algorithm>>
TC: O(N) | SC: O(1)

Iterate through the array whilst maintaining two variables,
'currSum' and 'maxSum' that store the current and maximum sum
of the array respectively.

If currSum ever becomes less than 0, re-initialize it to 0 
as the sum of an empty sub-array is taken to be 0.

<<Next Permutation>>
TC: O(N) | SC: O(1)

Assuming the longest possible prefix match, find the break-point
in ascending order of numbers while traversing the array from right-to-left.

Once break-point is found, find the first element that occurs in the array
(going from right-to-left) that is greater than break-point 
(so that difference between current and next permutation is minimized).
Swap the break-point with this number.

Finally, reverse the array after break-point's index to get the next permutation.
Essentially, we are sorting the array (due to the ascending order of their occurance)
in a better time complexity.

<<Minimum Number of Platforms>>
TC: O(NlogN) | SC: O(1)

We know that at any given moment, one platform can accomodate at max one train only.
Therefore, if we were to sort the arrival and departure times of trains individually, 
we will be able to compute when a platform will be occupied.

To find out the minimum number of platforms required, we can keep two variables, 
'platformsOccupied' and 'platformsRequired', which will store the number of platforms
currently occupied and the maximum value of the former at any given time respectively.

Now, we will traverse through the array(s). Every time the current value of arrival
time is less than (or equal to) the current value of departure time, the train will
occupy a new platform and every time the arrival time is greater than the departure
time, we can free up a platform.

NOTE: We are not concerned with matching the arrival time of a train to its departure
time as we need ONLY the number of platforms required.

<<Reverse Linked List>>
TC: O(N) | SC: O(1)

We can use two pointers, namely 'prevNode' and 'nextNode' and initialize them both to NULL. 
Re-arrange the links of the list such that prevNode and nextNode point to the 
previous and next node of the current node respectively. Repeat this process till current 
node is not equal to NULL. Return prevNode as head of new linked list.

<<Job Sequencing Problem>>
TC: O(NlogN) + O(N*k) | SC: O(k)

Since we want to maximize our profits, we will sort the given array in descending order of
the profits that they will yield. Afterwards, we will try to maximize our profits by performing
every job on its last day so as to accomodate as many jobs as possible. 

First, we will declare a boolean array 'jobSchedule' of size equal to the job that has the largest deadline
and initialize each of its value to false. The size is taken such because the job with the 
largest deadline is the amount of time we have to select jobs and maximize our profit.

Now, we will iterate through the jobs array and populare our jobSchedule array with it.
Since it is desirable to finish each job at its last possible day, we will start by checking
whether that day is vacant (false) or not. If yes, we will set to do that job on its last day.
If not, we will iterate through jobSchedule array in reverse till we find a vacant day for it.
Upon finding it, we will add its profit to 'maxProfit' and continue doing so for the rest of the jobs.

<<Middle Of Linked List>>
TC: O(N) | SC: O(1)

We will use the slow-fast pointer approach in this problem, where the 'slow' pointer will be incremented
by one node per iteration and the 'fast' pointer will be incremented by two nodes per iteration. We will 
continue this process till fast and the next node pointed by fast are not equal to NULL. When either of
these conditions fail, the slow pointer will point to the middle of the linked list, irrespective of the
number of nodes in the linked list.

<<Find Minimum Number Of Coins>>
TC: O(k) | SC: O(1)

Since we need to find the minimum number of coins needed, we will try to take the maximum number of coins
from the largest denomination possible and continue doing so till the amount to be formed is reduced to zero.

We will iterate the 'denominations' array in reverse, taking the maximum possible amount of each denomination 
possible till the amount to be formed is zero.

NOTE: The greedy approach works in this case as the sum of no two denominations is equal to a third one.
If this was the case, we would need to use dynamic programming. 

Eg. denominations = [1, 5, 6, 9], amount = 11
    Greedy Answer = 3 (9 + 1 + 1) [WRONG]
    DP Answer = 2 (6 + 5) [CORRECT]

<<Reverse Words In A String>>
TC: O(N) | SC: O(1)

If we want to achieve constant space complexity whilst maintaining linear time complexity,
we will have to make changes in the given string to do so.

Declare two pointers 'i' and 'j' and initialize them to the length of the string.
They shall indicate the end of the original string and the last letter of a word respectively.
Append a space at the end of the original string to earmark the beginning of the desired string.

Decrement j till the first space character is encountered. Declare a new variable 'k', 
and initialize it the value one less than the index of j.

Now, decrement k till the first space is encountered. The characters between j and k form the word
that is to be appended at the end of the given string.

Append the word to the end of the string along with a space and repeat this process till j is in range.

Return the substring between i and the end of the string.

<<Fractional Knapsack>>
TC: O(NlogN) | SC: O(1)

We want to maximize the amount in our knapsack. To do so, we will choose items with the 
highest value per weight. Sort the given array in descending order of their value per weight.

Now, traverse the array and choose items to put in the knapsack. If the total weight of an item is
less than or equal to the amount of space left in the knapsack, choose that item in its entirety.

Else, determine the value per weight of that item and choose its weight equivalent to the space left 
in the knapsack.

NOTE: Keep check of explicit type conversion while determining the unit values.

<<Set Matrix Zeros>>
TC: O(N*M) | SC: O(1)

If an element matrix[i][j] is equal to zero, we need to make all elements of the ith row and the jth 
column equal to zero. Thus, if this condition is found to be true, we can make the zeroth element of the
ith row and jth column equal to 0 during our first traversal of the matrix and later, in our second traversal,
make all elements of the row and column 0.

In order to keep track whether all elements of the zeroth column are to be made 0, we can declare a boolean
variable 'colZero' that keeps track of the same. 

<<Maximum Meetings>> AND <<Maximum Activities>>
TC: O(NlogN) | SC: O(N)

Since we need to choose the maximum number of meetings to be held in a room, we need to select those meetings 
that finish the earliest i.e. have shortest end time. Therefore, we need to combine the start and end times of the meetings 
into a single array and sort them by their end times. 

Now, we will iterate through said combined array whilst maintaining a variable 'lastMeetingEndTime' that as its name indicates, 
will store the ending time of the last meeting we select. Another variable 'meetingsOrganized' will keep track of the number
of meetings will be able to organize.

NOTE: Initialize meetingsOrganized as 1 since we will be able to organize at least 1 meeting

If the starting time of the current meeting is strictly greater than lastMeetingEndTime, we will be able to organize this meeting.
Increment meetingsOrganized accordingly and assign to lastMeetingEndTime the ending time of the current meeting and move to the 
next meeting.

<<Subset Sum>>
TC: O(2^NlogN) | SC: ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

To find out the sum of each subarray, we first need to recursively generate them. For this, we can create a function 
'generateSubset' that will iterate through each element of the array and be recursively called for each of its two sub-cases: 
either selecting the current element and adding it to the subset, or not selecting it.

This process is to be continued till the current index is equal to the size of the array, after which we have to return to 
the calling function. Once all subsets have been generated, we need to sort them since that is the requirement of the problem.

<<Inorder Traversal>> AND <<Preorder Traversal>> AND <<Postorder Traversal>>
TC: O(N) | SC: O(N) [worst case: skew trees]

Preorder: Node Left Right
Inorder: Left Node Right
Postorder: Left Right Node

<<Morris Inorder Traversal>>
TC: O(N) | SC: O(1)

If left of curr exists, point the right-most node of the left sub-tree of curr to itself and then move curr to its left.
Else, print curr and move curr to its right.

// pointing right-most node of left sub-tree of curr to itself

Initialize a TreeNode 'prev' as left of curr and continue moving it to its right till its right in not NULL and 
not equal to curr itself.

If right of prev is equal to curr, it means that a thread already exists. Remove it by pointing right of prev to NULL, 
print curr and move it to its right.

Else, point right of prev to curr and move curr to its left.

<<Left View of Binary Tree>>
TC: O(N) | SC: O(H)

Through observation, we find out that the left view of a binary tree contains all the first nodes of each level.
Therefore, we use preorder traversal on it and whenever the level of the binary tree is equal to the array used to 
store the left view nodes, we push it back into our solution.

<<Bottom View of Binary Tree>>
TC: O(NlogN) | SC: O(N)

We can think of the binary tree as a group of lines, with the root being line 0, and every child to the left or 
right of a node as one line lesser or greater than it respectively.

In doing so, we can store all nodes (starting from the root) in a queue that contains a vector of pairs of 
a node and its line. We would also require a map to store the unique node corresponding to each line.

With the root and its line (i.e. 0) pushed into the queue, we will assign its line to its node in the map. 
If its children exist in the tree, we shall push them into the queue as well, with their line incremented or 
decremented by 1 if they are the left or right child respectively.

Since we are done processing the current element of the queue, we can pop it out and repeat this process till 
it is empty.

Finally, we can push all the second values of the map (containing node data) into a solution vector to get 
the bottom view nodes of the given tree.

<<Top View of Binary Tree>>
TC: O(NlogN) | SC: O(N) 

Similar to 'Bottom View of Binary Tree'. Instead of over-writing node->val in map for a line, first check if 
it exists in the map. If yes, do NOT over-write it. We need the first value of each line. Else, insert it.

<<Majority Element (>nÃ·2 times)>>
TC: O(N) | SC: O(1)

Initialize and declare two variable 'majEle' and 'ctr' to the 0th element of the array and 1 respectively.
Iterate through the given array (starting from the first element) and whenever the ith element is equal to majEle, 
increment ctr. Else, decrement it. If ctr is ever equal to 0, re-initialize it 1 and assign the current element as majEle.

If a major element exists in the array, it is equal to majEle. Else, no major element exists in the array.

Iterate through the array again, and count the number of times majEle occurs in it. If its frequency is greater than n/2,
return majEle. Else, return -1.

<<Largest Subarray with K Sum>>
TC: O(N^2) | SC: O(N)

Declare two variables 'maxLen' and 'preSum' and initialize them both to zero. These shall store the maximum length of 
subarray with sum equal to zero and the prefix sum upto the current index respectively.

Declare an unordered map 'preSumIdx' that shall store the earliest index of a specific prefix sum. Insert (0, -1) into 
the map as the prefix sum 0 is achieved at the -1th index.

Iterate through the array and add the element to preSum. If the preSum already exists in the array, find the distance between 
the current index and the index this preSum occured at first. Assign to maxLen the maximum value between the two.

If the preSum does not exist in the array, insert it. Finally, return maxLen.

<<Merge Intervals>>
TC: O(NlogN) | SC: O(1)

If two intervals are overlapping, the new interval will start from the starting time of the first interval 
and end at the ending time of the maximum end time of the two intervals.

This approach can be generalised for n intervals: If n intervals are overlapping, the resultant interval 
will start at the starting time of the first interval and end at the ending time of the maximum end time of the n intervals.

<<Count Inversions>>
TC: O(NlogN) | SC: O(N)

If there exist two sorted arrays 'a' and 'b' andsuch that the ith element of a is greater than the jth element of b, 
then all the elements to the right of a will surely be greater b[j].

We can find this situation in merge sort when we are merging two sorted arrays to form the final array. While we are 
at this step, we can keep track of the inversions using a variable that is incremented by the difference between 
n1 (the size of array a) and i (current index of a) whenever a[i] > b[j].

<<Missing and Repeating Number>>
TC: O(N) | SC: O(1)

Take sum of all elements in the array. Deduce sum of all integers from 1 to n using formula. Subtract the two values.
This should be equal to (R-M).

Take sum of square of all elements in array. Deduce sum of squares of all integers from 1 to n using formula. 
Subtract the two values. Divide it by (R-M). This should be equal to (R+M).

Solve the two equations to deduce the values of R and M respectively.

<<Merge Two Sorted Arrays>>
TC: O(N+M) | SC: O(1)

Declare and initialize 3 pointers i, j and k to the last non-zero integer in arr1, last integer in arr2 and 
last intger in arr1 respectively.

While i and j both are greater than -1, compare the ith and jth element of arr1 and arr2 respectively.

If arr1[i] is greater than arr2[j], assign the value at arr1[i] to arr1[k] and decrement both the pointers.
Else, assign the value at arr2[j] to arr1[k] and decrement both the pointers.

When the loop is exited, one of the two conditions is still true. Thus, we will populate the array with 
the remaning elements.

Iterate through arr1 and assign the value at arr1[i] to arr1[k] and decrement both the pointers.
Repeat the process for arr2 as well.

<<Cycle Detection in a Singly Linked List>>
TC: O(N) | SC: O(1)

If head or the node next to head is NULL, we can be sure that no cycle exists in the linked list.
Declare two pointers 'slow' and 'fast' and make them point to the head of the linked list. While fast and the 
node after  fast are not NULL, move slow to its next and fast to the next of its next node respectively. 
If at any point slow and fast are equal to each other, we can say that a cycle exists in the linked list.

INTUITION: In a circular linked list, if fast is one node behind slow, then in the next iteration, 
they will point to the same node. If fast is two nodes behind slow, the next iteration will reduce the gap 
to one node and the one after that will make them point to the same node.

<<Linked List Cycle II>>
TC: O(N) | SC: O(1)

Let l1 be the distance from head to starting of loop and l2 be the distance from starting of loop to first 
node where s and f collide.

Therefore, s travels l1+l2 distance before first collision. Since s and f are colliding, 
f would've also covered at least l1+l2. However, since f moves twice as fast as s, 
it would've made a couple of laps of the loop before meeting s at point of collision.

Therefore, total distance travelled by f would be l1+l2+nC where n is the number of laps travelled 
before meeting s and C is the length of the loop.

Since travels twice as fast as s, for the same number of iterations, f would cover twice the distance as s.

i.e. 2(l1+l2) = l1+l2+nC
=> nC = l1+l2
=> l1 = nC-l2

And since l1 is the distance from head to entry of loop, the time taken to go from head to entry would be the same
as the time taken to go from point of collision to entry.


<<Find Duplicate in Array>>
TC: O(N) | SC: O(1)

For this question, we will use the 'Linked List Cycle Method', since there exists one element with duplicate(s).

Declare two integer variabls 'slow' and 'fast' and initialize them to the zeroth index of the array. 
While they are not equal to each other, assign to slow the value at the slow'th index of the array and 
to fast, the value at the fast'th index of the fast'th index of the array. 

When the loop is exited, assign to fast the value at the zeroth index of the array. 
While slow and fast are not equal, assign to slow the value at the slow'th index of the array and to fast, 
the value at the fast'th index. Return slow.

<<Intersection of Two Linked Lists>>
TC: O(M+N) | SC: O(1)

Declare two node pointers 'ptr1' and 'ptr2' and initialize them to the heads of the given linked lists respectively. 
Till they both point to the same nodes, move them to their respective next nodes. When ptr1 becomes NULL, 
move it to the head of the second linked list. Do the same for ptr2 too when it becomes NULL.

The loop will be exited when both the pointers point to the same node. If the two linked lists intersect, this node 
will be the intersecting node. If not, loop will be exited when both are NULL.

INTUITION: When the node pointer of the shorter linked list reaches NULL, the number of nodes between the two node 
pointers is equal to the difference of their lenghts. When we assign them to each others head upon reaching NULL, 
we reset this difference. By the time the node of the longer linked list reaches NULL and is re-assigned to the head of
the shorter linked list, the node pointers are aligned to meet at the intersecting node.

<<Preorder, Inorder, Postorder in Single Traversal>>
TC:O(N) | SC: O(N)

Declare three vectors 'inNodes', 'preNodes' and 'postNodes' that will store the nodes of the binary tree when traversed in
inorder, preorder and postorder respectively.

Declare a stack that stores pairs of TreeNodes and integers. This shall be used to store the node and its 'stage'.
Push onto root node and 1 onto the stack.

Assign the node and stage to suitable variables and pop off the top node of the stack.  

If the stage of the current node is 1, insert its value into preNodes and push onto the stack the same node, but with 
its stage incremented by 1. If its left child exists, push the child onto the stack with its stage as 1.

Else, if the stage of the current node is 2, insert its value into inNodes and push onto the stack the same node, but with 
its stage incremented by 1. If its right child exists, push the child onto the stack with its stage as 1.

For all other cases, insert the node's value into the stack as it is.

Repeat the process till stack is not empty.

<<Vertical Order Traversal>>
TC: O(N) | SC: O(N)

Declare a queue that will store which line a node is at and a map that will indicate the nodes present at a given line.
Push the root node, along with its line (i.e. 0) onto the queue.

Assign the node and line to suitable variables and pop off the node from the queue. Push the node's data onto its line on the map.
If a left child of the node exists, push it onto the queue along with its line (decremented by 1). Do the same for the right child.

Repeat the process till the queue is not empty. Finally, push all the elements of the map (line-wise) onto the solution array.

<<Path in a Tree>>
TC: O(N) | SC: O(H)

We will traverse the given binary tree recursively using inorder traversal.

First, check if current node is NULL; if yes, return false. 
Add node's data to path array.

Now, check if current node is equal to desired node; if yes, return true.
Repeat the process for children of current node (first left, then right).
If either of them return true, return true.

Pop last value from array and return false. 
