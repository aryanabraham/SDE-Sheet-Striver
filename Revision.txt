<<Sort an array of 0's, 1's and 2's>>
TC: O(N) | SC: O(1)

Divide the array into three parts such that after traversal, 
all integers left of 'low' are equal to 0, 
all integers right of 'high' are equal to 2
and all integers between the two are equal to 1.

<<Kadane's Algorithm>>
TC: O(N) | SC: O(1)

Iterate through the array whilst maintaining two variables,
'currSum' and 'maxSum' that store the current and maximum sum
of the array respectively.

If currSum ever becomes less than 0, re-initialize it to 0 
as the sum of an empty sub-array is taken to be 0.

<<Next Permutation>>
TC: O(N) | SC: O(1)

Assuming the longest possible prefix match, find the break-point
in ascending order of numbers while traversing the array from right-to-left.

Once break-point is found, find the first element that occurs in the array
(going from right-to-left) that is greater than break-point 
(so that difference between current and next permutation is minimized).
Swap the break-point with this number.

Finally, reverse the array after break-point's index to get the next permutation.
Essentially, we are sorting the array (due to the ascending order of their occurance)
in a better time complexity.

<<Minimum Number of Platforms>>
TC: O(NlogN) | SC: O(1)

We know that at any given moment, one platform can accomodate at max one train only.
Therefore, if we were to sort the arrival and departure times of trains individually, 
we will be able to compute when a platform will be occupied.

To find out the minimum number of platforms required, we can keep two variables, 
'platformsOccupied' and 'platformsRequired', which will store the number of platforms
currently occupied and the maximum value of the former at any given time respectively.

Now, we will traverse through the array(s). Every time the current value of arrival
time is less than (or equal to) the current value of departure time, the train will
occupy a new platform and every time the arrival time is greater than the departure
time, we can free up a platform.

NOTE: We are not concerned with matching the arrival time of a train to its departure
time as we need ONLY the number of platforms required.

<<Reverse Linked List>>
TC: O(N) | SC: O(1)

We can use two pointers, namely 'prevNode' and 'nextNode' and initialize them both to NULL. 
Re-arrange the links of the list such that prevNode and nextNode point to the 
previous and next node of the current node respectively. Repeat this process till current 
node is not equal to NULL. Return prevNode as head of new linked list.

<<Job Sequencing Problem>>
TC: O(NlogN) + O(N*k) | SC: O(k)

Since we want to maximize our profits, we will sort the given array in descending order of
the profits that they will yield. Afterwards, we will try to maximize our profits by performing
every job on its last day so as to accomodate as many jobs as possible. 

First, we will declare a boolean array 'jobSchedule' of size equal to the job that has the largest deadline
and initialize each of its value to false. The size is taken such because the job with the 
largest deadline is the amount of time we have to select jobs and maximize our profit.

Now, we will iterate through the jobs array and populare our jobSchedule array with it.
Since it is desirable to finish each job at its last possible day, we will start by checking
whether that day is vacant (false) or not. If yes, we will set to do that job on its last day.
If not, we will iterate through jobSchedule array in reverse till we find a vacant day for it.
Upon finding it, we will add its profit to 'maxProfit' and continue doing so for the rest of the jobs.

<<Middle of Linked List>>
TC: O(N) | SC: O(1)

We will use the slow-fast pointer approach in this problem, where the 'slow' pointer will be incremented
by one node per iteration and the 'fast' pointer will be incremented by two nodes per iteration. We will 
continue this process till fast and the next node pointed by fast are not equal to NULL. When either of
these conditions fail, the slow pointer will point to the middle of the linked list, irrespective of the
number of nodes in the linked list.
