<<Sort an array of 0's, 1's and 2's>>
TC: O(N) | SC: O(1)

Divide the array into three parts such that after traversal, 
all integers left of 'low' are equal to 0, 
all integers right of 'high' are equal to 2
and all integers between the two are equal to 1.

<<Kadane's Algorithm>>
TC: O(N) | SC: O(1)

Iterate through the array whilst maintaining two variables,
'currSum' and 'maxSum' that store the current and maximum sum
of the array respectively.

If currSum ever becomes less than 0, re-initialize it to 0 
as the sum of an empty sub-array is taken to be 0.

<<Next Permutation>>
TC: O(N) | SC: O(1)

Assuming the longest possible prefix match, find the break-point
in ascending order of numbers while traversing the array from right-to-left.

Once break-point is found, find the first element that occurs in the array
(going from right-to-left) that is greater than break-point 
(so that difference between current and next permutation is minimized).
Swap the break-point with this number.

Finally, reverse the array after break-point's index to get the next permutation.
Essentially, we are sorting the array (due to the ascending order of their occurance)
in a better time complexity.

<<Minimum Number of Platforms>>
TC: O(NlogN) | SC: O(1)

We know that at any given moment, one platform can accomodate at max one train only.
Therefore, if we were to sort the arrival and departure times of trains individually, 
we will be able to compute when a platform will be occupied.

To find out the minimum number of platforms required, we can keep two variables, 
'platformsOccupied' and 'platformsRequired', which will store the number of platforms
currently occupied and the maximum value of the former at any given time respectively.

Now, we will traverse through the array(s). Every time the current value of arrival
time is less than (or equal to) the current value of departure time, the train will
occupy a new platform and every time the arrival time is greater than the departure
time, we can free up a platform.

NOTE: We are not concerned with matching the arrival time of a train to its departure
time as we need ONLY the number of platforms required.

<<Reverse Linked List>>
TC: O(N) | SC: O(1)

We can use two pointers, namely 'prevNode' and 'nextNode' and initialize them both to NULL. 
Re-arrange the links of the list such that prevNode and nextNode point to the 
previous and next node of the current node respectively. Repeat this process till current 
node is not equal to NULL. Return prevNode as head of new linked list.

<<Job Sequencing Problem>>
TC: O(NlogN) + O(N*k) | SC: O(k)

Since we want to maximize our profits, we will sort the given array in descending order of
the profits that they will yield. Afterwards, we will try to maximize our profits by performing
every job on its last day so as to accomodate as many jobs as possible. 

First, we will declare a boolean array 'jobSchedule' of size equal to the job that has the largest deadline
and initialize each of its value to false. The size is taken such because the job with the 
largest deadline is the amount of time we have to select jobs and maximize our profit.

Now, we will iterate through the jobs array and populare our jobSchedule array with it.
Since it is desirable to finish each job at its last possible day, we will start by checking
whether that day is vacant (false) or not. If yes, we will set to do that job on its last day.
If not, we will iterate through jobSchedule array in reverse till we find a vacant day for it.
Upon finding it, we will add its profit to 'maxProfit' and continue doing so for the rest of the jobs.

<<Middle Of Linked List>>
TC: O(N) | SC: O(1)

We will use the slow-fast pointer approach in this problem, where the 'slow' pointer will be incremented
by one node per iteration and the 'fast' pointer will be incremented by two nodes per iteration. We will 
continue this process till fast and the next node pointed by fast are not equal to NULL. When either of
these conditions fail, the slow pointer will point to the middle of the linked list, irrespective of the
number of nodes in the linked list.

<<Find Minimum Number Of Coins>>
TC: O(k) | SC: O(1)

Since we need to find the minimum number of coins needed, we will try to take the maximum number of coins
from the largest denomination possible and continue doing so till the amount to be formed is reduced to zero.

We will iterate the 'denominations' array in reverse, taking the maximum possible amount of each denomination 
possible till the amount to be formed is zero.

NOTE: The greedy approach works in this case as the sum of no two denominations is equal to a third one.
If this was the case, we would need to use dynamic programming. 

Eg. denominations = [1, 5, 6, 9], amount = 11
    Greedy Answer = 3 (9 + 1 + 1) [WRONG]
    DP Answer = 2 (6 + 5) [CORRECT]

<<Reverse Words In A String>>
TC: O(N) | SC: O(1)

If we want to achieve constant space complexity whilst maintaining linear time complexity,
we will have to make changes in the given string to do so.

Declare two pointers 'i' and 'j' and initialize them to the length of the string.
They shall indicate the end of the original string and the last letter of a word respectively.
Append a space at the end of the original string to earmark the beginning of the desired string.

Decrement j till the first space character is encountered. Declare a new variable 'k', 
and initialize it the value one less than the index of j.

Now, decrement k till the first space is encountered. The characters between j and k form the word
that is to be appended at the end of the given string.

Append the word to the end of the string along with a space and repeat this process till j is in range.

Return the substring between i and the end of the string.

<<Fractional Knapsack>>
TC: O(NlogN) | SC: O(1)

We want to maximize the amount in our knapsack. To do so, we will choose items with the 
highest value per weight. Sort the given array in descending order of their value per weight.

Now, traverse the array and choose items to put in the knapsack. If the total weight of an item is
less than or equal to the amount of space left in the knapsack, choose that item in its entirety.

Else, determine the value per weight of that item and choose its weight equivalent to the space left 
in the knapsack.

NOTE: Keep check of explicit type conversion while determining the unit values.

<<Set Matrix Zeros>>
TC: O(N*M) | SC: O(1)

If an element matrix[i][j] is equal to zero, we need to make all elements of the ith row and the jth 
column equal to zero. Thus, if this condition is found to be true, we can make the zeroth element of the
ith row and jth column equal to 0 during our first traversal of the matrix and later, in our second traversal,
make all elements of the row and column 0.

In order to keep track whether all elements of the zeroth column are to be made 0, we can declare a boolean
variable 'colZero' that keeps track of the same. 

<<Maximum Meetings>> AND <<Maximum Activities>>
TC: O(NlogN) | SC: O(N)

Since we need to choose the maximum number of meetings to be held in a room, we need to select those meetings 
that finish the earliest i.e. have shortest end time. Therefore, we need to combine the start and end times of the meetings 
into a single array and sort them by their end times. 

Now, we will iterate through said combined array whilst maintaining a variable 'lastMeetingEndTime' that as its name indicates, 
will store the ending time of the last meeting we select. Another variable 'meetingsOrganized' will keep track of the number
of meetings will be able to organize.

NOTE: Initialize meetingsOrganized as 1 since we will be able to organize at least 1 meeting

If the starting time of the current meeting is strictly greater than lastMeetingEndTime, we will be able to organize this meeting.
Increment meetingsOrganized accordingly and assign to lastMeetingEndTime the ending time of the current meeting and move to the 
next meeting.

<<Subset Sum>>
TC: O(2^NlogN) | SC: ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

To find out the sum of each subarray, we first need to recursively generate them. For this, we can create a function 
'generateSubset' that will iterate through each element of the array and be recursively called for each of its two sub-cases: 
either selecting the current element and adding it to the subset, or not selecting it.

This process is to be continued till the current index is equal to the size of the array, after which we have to return to 
the calling function. Once all subsets have been generated, we need to sort them since that is the requirement of the problem.

<<Inorder Traversal>> AND <<Preorder Traversal>> AND <<Postorder Traversal>>
TC: O(N) | SC: O(N) [worst case: skew trees]

Preorder: Node Left Right
Inorder: Left Node Right
Postorder: Left Right Node

<<Morris Inorder Traversal>>
TC: O(N) | SC: O(1)

If left of curr exists, point the right-most node of the left sub-tree of curr to itself and then move curr to its left.
Else, print curr and move curr to its right.

// pointing right-most node of left sub-tree of curr to itself

Initialize a TreeNode 'prev' as left of curr and continue moving it to its right till its right in not NULL and 
not equal to curr itself.

If right of prev is equal to curr, it means that a thread already exists. Remove it by pointing right of prev to NULL, 
print curr and move it to its right.

Else, point right of prev to curr and move curr to its left.
