<<Sort an array of 0's, 1's and 2's>>
TC: O(N) | SC: O(1)

Divide the array into three parts such that after traversal, 
all integers left of 'low' are equal to 0, 
all integers right of 'high' are equal to 2
and all integers between the two are equal to 1.

<<Kadane's Algorithm>>
TC: O(N) | SC: O(1)

Iterate through the array whilst maintaining two variables,
'currSum' and 'maxSum' that store the current and maximum sum
of the array respectively.

If currSum ever becomes less than 0, re-initialize it to 0 
as the sum of an empty sub-array is taken to be 0.

<<Next Permutation>>
TC: O(N) | SC: O(1)

Assuming the longest possible prefix match, find the break-point
in ascending order of numbers while traversing the array from right-to-left.

Once break-point is found, find the first element that occurs in the array
(going from right-to-left) that is greater than break-point 
(so that difference between current and next permutation is minimized).
Swap the break-point with this number.

Finally, reverse the array after break-point's index to get the next permutation.
Essentially, we are sorting the array (due to the ascending order of their occurance)
in a better time complexity.

<<Minimum Number of Platforms>>

We know that at any given moment, one platform can accomodate at max one train only.
Therefore, if we were to sort the arrival and departure times of trains individually, 
we will be able to compute when a platform will be occupied.

To find out the minimum number of platforms required, we can keep two variables, 
'platformsOccupied' and 'platformsRequired', which will store the number of platforms
currently occupied and the maximum value of the former at any given time respectively.

Now, we will traverse through the array(s). Every time the current value of arrival
time is less than (or equal to) the current value of departure time, the train will
occupy a new platform and every time the arrival time is greater than the departure
time, we can free up a platform.
